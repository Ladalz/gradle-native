import dev.nokee.docs.tasks.CreateAsciinema
import dev.nokee.platform.ios.fixtures.ObjectiveCIosApp
import dev.nokee.platform.jni.fixtures.*

import java.text.SimpleDateFormat

buildscript {
	dependencies {
		classpath 'dev.nokee:templates:latest.integration'
	}
}

plugins {
	id 'dev.nokeebuild.documentation'
	id 'maven-publish'
	id 'antlr'
}

docsTest.dependsOn({ project(':distributions').tasks.named('publishToStaging')})
tasks.withType(CreateAsciinema).configureEach {
	dependsOn({ project(':distributions').tasks.named('publishToStaging')})
}

// The following inputs cause the task to never be up-to-date.
// The solution would be to correctly declare the input/output for `publishToStaging` so it doesn't republish when nothing has changed (and dependencies)
// For now, it's ok, let's solve this when it becomes a real problem.
docsTest.inputs.dir(fileTree(dir: rootProject.file('subprojects/distributions/build/repository'), includes:["**/${rootProject.version}/**/*"]))
docsTest.inputs.dir(layout.buildDirectory.dir("generated/samples"))
docsTest.systemProperty('dev.nokee.docsRepository', rootProject.file('subprojects/distributions/build/repository').absolutePath)
docsTest.systemProperty('sampleContentDirectory', layout.buildDirectory.dir("generated/samples").get().asFile.absolutePath)
docsTest.dependsOn('assembleSamples')
dependencies {
	docsTestImplementation 'org.asciidoctor:asciidoctorj-api:2.2.0'
	docsTestImplementation 'org.asciidoctor:asciidoctorj:2.2.0'
	docsTestImplementation("dev.gradleplugins:gradle-fixtures:${toolboxVersion}") {
		capabilities {
			requireCapability('dev.gradleplugins:gradle-fixtures-spock-support')
		}
	}
	docsTestCompileOnly "dev.gradleplugins:gradle-api:${minimumGradleVersion}" // Is this really needed?
	docsTestCompileOnly gradleTestKit() // Because of java.lang.NoClassDefFoundError: kotlin/jvm/functions/Function0 from AbstractInstalledToolChains
	docsTestRuntimeOnly "dev.gradleplugins:gradle-api:${minimumGradleVersion}" // Because of the gradle-fixtures AbstractInstalledToolChainIntegrationSpec

	docsTestCompileOnly "org.projectlombok:lombok:${lombokVersion}"
	docsTestAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"

	docsTestImplementation 'org.apache.commons:commons-lang3:3.9'
	docsTestImplementation 'org.hamcrest:hamcrest:2.2'

	docsTestImplementation "org.antlr:antlr4:${antlrVersion}"
	antlr "org.antlr:antlr4:${antlrVersion}"

	docsTestImplementation 'commons-io:commons-io:2.6'
	docsTestImplementation 'net.sourceforge.nekohtml:nekohtml:1.9.21'
	docsTestImplementation 'io.github.http-builder-ng:http-builder-ng-core:1.0.4'
	docsTestImplementation 'com.google.guava:guava:28.2-jre'
	docsTestImplementation testFixtures('dev.nokee.docs:docs-gradle-plugin:latest.integration')
	docsTestImplementation 'org.codehaus.groovy:groovy-all:2.5.2' // Need to look into this
	docsTestImplementation 'org.jetbrains.kotlin:kotlin-stdlib:1.3.71' // Because of java.lang.NoClassDefFoundError: kotlin/jvm/functions/Function0 from AbstractInstalledToolChains
}
// TODO: Improve this Antlr mess... :(
afterEvaluate {
	sourceSets.docsTest.groovy.srcDirs(sourceSets.docsTest.java.srcDirs)
	sourceSets.docsTest.java.srcDirs = []
}
compileGroovy.dependsOn(generateDocsTestGrammarSource)

repositories {
	maven { url = 'https://dl.bintray.com/gradle-plugins/distributions' }
}

documentation {
	samples {
		'java-cpp-jni-library' {
			template = new JavaJniCppGreeterLib('java-cpp-jni-library')
		}
		'java-c-jni-library' {
			template = new JavaJniCGreeterLib('java-c-jni-library')
		}
		'java-objective-c-jni-library' {
			template = new JavaJniObjectiveCGreeterLib('java-objective-c-jni-library')
		}
		'java-objective-cpp-jni-library' {
			template = new JavaJniObjectiveCppGreeterLib('java-objective-cpp-jni-library')
		}
		'jni-library-with-junit-test' {
			template = new JavaJniCppGreeterLib('jni-library-with-junit-test').withJUnitTest()
		}
		'jni-library-with-target-machines' {
			template = new JavaJniCppGreeterLib('jni-library-with-target-machines')
		}
		'jvm-application-with-jni-library' {
			template = new GreeterAppWithJniLibrary('jvm-application-with-jni-library').withLibraryAsSubproject('jni-library')
		}
		'jni-library-composing' {
			template = new JavaJniCppGreeterLib('jni-library-composing').withImplementationAsSubprojects()
		}
		'publish-jni-library' {
			template = new JavaJniCppGreeterLib('publish-jni-library')
		}
		'publish-jni-library-with-target-machines' {
			template = new JavaJniCppGreeterLib('publish-jni-library-with-target-machines')
		}
		'jni-library-with-resource-path' {
			template = new JavaJniCppGreeterLib('jni-library-with-resource-path')
		}
		'jni-library-with-framework-dependencies' {
			template = new JavaJniCppGreeterLib('jni-library-with-framework-dependencies')
		}
		'jni-library-as-uber-jar' {
			template = new JavaJniCppGreeterLib('jni-library-as-uber-jar')
		}

		'objective-c-ios-application' {
			template = new ObjectiveCIosApp()
		}
	}
}


publishing {
	publications {
		jbake(MavenPublication) {
			from components.jbake
			artifactId = 'jbake'
			group = 'dev.nokee.docs'
			// Use date/time as the version because commits mess-up the "latest" search
			version = new SimpleDateFormat("yyyyMMddHHmm").format(new Date())
		}
		baked(MavenPublication) {
			from components.baked
			artifactId = 'nightly'
			group = 'dev.nokee.docs'
			// Use date/time as the version because commits mess-up the "latest" search
			version = new SimpleDateFormat("yyyyMMddHHmm").format(new Date())
		}
	}
	repositories {
		maven {
			name = 'S3'
			credentials(AwsCredentials) {
				it.accessKey = resolveProperty(project, "AWS_ACCESS_KEY", "dev.nokee.aws.user")
				it.secretKey = resolveProperty(project, "AWS_SECRET_KEY", "dev.nokee.aws.key")
			}
			url = 's3://docs.nokee.dev/'
		}
	}
}

private String resolveProperty(Project project, String envVarKey, String projectPropKey) {
	Object propValue = System.getenv().get(envVarKey);

	if (propValue != null) {
		return propValue.toString();
	}

	propValue = project.findProperty(projectPropKey);
	if (propValue != null) {
		return propValue.toString();
	}

	return null;
}

afterEvaluate {
	tasks.withType(CreateAsciinema).configureEach {
		onlyIf {
			return !project.hasProperty('skipAllAsciinemaTasks')
		}
	}
	['extractDocsScreenshot', 'compileDocsAsciicast'].each { name ->
		tasks.named(name) {
			onlyIf {
				return !project.hasProperty('skipAllAsciinemaTasks')
			}
		}
	}
}

tasks.register('bakedDocsTest', Test) { task ->
	task.group(LifecycleBasePlugin.VERIFICATION_GROUP)
	task.dependsOn('assembleDocumentation')
	tasks.docsTest.copyTo((JavaForkOptions)task)
	task.inputs.dir(layout.buildDirectory.dir('generated/baked'))
	task.systemProperty('bakedContentDirectory', layout.buildDirectory.dir('generated/baked').get().asFile.absolutePath)
	task.useJUnit {
		includeCategories('dev.nokee.docs.tags.Baked')
	}
	task.testClassesDirs = tasks.docsTest.testClassesDirs
	task.classpath = tasks.docsTest.classpath
}

tasks.named('docsTest', Test) { task ->
	task.dependsOn('assembleSampleZips')
	task.useJUnit {
		excludeCategories('dev.nokee.docs.tags.Baked')
	}
	task.inputs.dir(layout.buildDirectory.dir('generated/zips'))
	task.systemProperty('sampleArchiveDirectory', layout.buildDirectory.dir('generated/zips').get().asFile.absolutePath)
}

tasks.named('stageDocumentation', Sync) {
	from(tasks.getByPath(':distributions:javadoc')) {
		into('docs/nightly/javadoc')
	}
}
